System model
A set of nodes connected into a network. Each node possesses an address needed to send messages to that node. Each node maintains addresses by means of a partial view, a set of c node descriptors (address and hop count).
The view is a list of c descriptors ordered by hop count. increaseHopCount() increases hop count of every descriptor in the view, merge(view1, view2) calculates union between two views and if two descriptors of the same node have different hop count we take the smaller hop count.

Peer Selection, View Propagation, View Selection are the three parameters to evaluate the system.

PEER SELECTION POLICIES
Uniform random selection from the view, or we select first or last node from the view (head or tail selection).

VIEW PROPAGATION POLICIES
Once a peer has been chosen, they exchange info in the following ways:
PUSH --> node sends its view to selected peer
PULL --> node requests view from selected peer
PUSHPULL --> does both

VIEW SELECTION POLICIES
Peers may need to truncate views in order to adhere to the c limit imposed on the view size.
selectView() selects a set of c elements
rand: uniform random selection of c elements
head: select first c elemets from view
tail: select last c elements from view

THE POLICIES GIVE A TOTAL OF 27 COMBINATIONS (pselection, vselection, vpropagation). For example we could have (random,random,pushpull)


THE MOTIVATIONS
There had never been any evaluation of the multitude of variants of gossip based membership dissemination. Also it is not 
clear whether these variants lead to uniform sampling.We introduce an experimental methodology to evaluate the gossip-based 
protocols, focusing on overlay networks.
We also want to define whether any of these methodologies have certain properties on an unstructured overlay network. Do the overlay networks induced by the peers exhibit stable properties or the convergence of properties? 
To what extent do these methodologies deviate from the desired random uniform distribution? 
What is the reliability measured in self-healing capacity and robustness to failure?
No istances however lead to uniform distribution.

EXPERIMENTAL METHODOLOGY
The GRAPH
If node a stores the descriptor of node b, then in the undirected graph we do have the edge (a,b). How similar is this overlay topology to a random graph?
We are interested in the convergence behavior to some stable property of the graph, for any combination-protocol. 
The graph is undirected since after initiating connection the passive party knows about the active party too.
PARAMETERS
Degree distribution --> degree of a node is the number of its neighbours, includes average degree and exact degree. The motivation for this is test robustness to failures as well as testing how well the "epidemic-based" scheme works, and see if there are communication hotspots in the overlay. We want a balanced degree distribution to get to the ideal of a random graph.
Average path length --> counted as shortest path between two nodes, to check scalability
Clustering coefficient--> the clustering coefficient of a node A is defined as NumEdgesBetweenNeighboursOf(a)/NumAllPossibleEdgesBetweenNeighboursOf(a). 
Tests extent to which neighbours are also neighbours of each other. The clustering coefficient of the graph is the average between the clustering coefficients of the nodes.
It always is between 0 and 1. High clustering coefficient may damage information dissemination, since it increases number of redundant messages, and on self-healing capacity, by 
weakening connection of a cluster to the rest of the graph increasing partitioning probability.

Settings
Nodes N = 10^4
Max view size c = 30

The simulation is organized into cycles in which at each cycle nodes may leave or join.
We do not consider variants (head,*,*) because they result in too much clustering, (*,tail,*) because they cannot handle joining nodes, and (*,*,pull) since they converge to a star topology which has a higlhy unbalanced degree distribution.
We look at the 8 topologies:
(random,head,push) (random, head, pushpull) (random, random, push) (random, random, pushpull), (tail, head, push) (tail, head, pushpull), (tail, random, push), (tail, random, pushpull)

